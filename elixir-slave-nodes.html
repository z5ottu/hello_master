<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">.lst-kix_txgin7vlyji-0>li:before{content:"\0025cf  "}.lst-kix_z1nuybmtkxll-8>li:before{content:"\0025a0  "}.lst-kix_txgin7vlyji-3>li:before{content:"\0025cf  "}.lst-kix_txgin7vlyji-4>li:before{content:"\0025cb  "}.lst-kix_z1nuybmtkxll-4>li:before{content:"\0025cb  "}.lst-kix_txgin7vlyji-5>li:before{content:"\0025a0  "}.lst-kix_z1nuybmtkxll-3>li:before{content:"\0025cf  "}ul.lst-kix_txgin7vlyji-5{list-style-type:none}.lst-kix_txgin7vlyji-7>li:before{content:"\0025cb  "}ul.lst-kix_txgin7vlyji-4{list-style-type:none}ul.lst-kix_txgin7vlyji-3{list-style-type:none}.lst-kix_txgin7vlyji-6>li:before{content:"\0025cf  "}.lst-kix_txgin7vlyji-8>li:before{content:"\0025a0  "}ul.lst-kix_txgin7vlyji-2{list-style-type:none}ul.lst-kix_txgin7vlyji-1{list-style-type:none}ul.lst-kix_txgin7vlyji-0{list-style-type:none}.lst-kix_z1nuybmtkxll-5>li:before{content:"\0025a0  "}ul.lst-kix_z1nuybmtkxll-1{list-style-type:none}ul.lst-kix_z1nuybmtkxll-0{list-style-type:none}.lst-kix_z1nuybmtkxll-6>li:before{content:"\0025cf  "}ul.lst-kix_z1nuybmtkxll-3{list-style-type:none}ul.lst-kix_z1nuybmtkxll-2{list-style-type:none}ul.lst-kix_z1nuybmtkxll-5{list-style-type:none}ul.lst-kix_z1nuybmtkxll-4{list-style-type:none}.lst-kix_z1nuybmtkxll-7>li:before{content:"\0025cb  "}ul.lst-kix_z1nuybmtkxll-7{list-style-type:none}ul.lst-kix_z1nuybmtkxll-6{list-style-type:none}ul.lst-kix_z1nuybmtkxll-8{list-style-type:none}ul.lst-kix_txgin7vlyji-8{list-style-type:none}ul.lst-kix_txgin7vlyji-7{list-style-type:none}ul.lst-kix_txgin7vlyji-6{list-style-type:none}.lst-kix_z1nuybmtkxll-0>li:before{content:"\0025cf  "}.lst-kix_z1nuybmtkxll-2>li:before{content:"\0025a0  "}.lst-kix_z1nuybmtkxll-1>li:before{content:"\0025cb  "}.lst-kix_txgin7vlyji-2>li:before{content:"\0025a0  "}.lst-kix_txgin7vlyji-1>li:before{content:"\0025cb  "}ol{margin:0;padding:0}table td,table th{padding:0}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c4{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:17pt;font-family:"Arial";font-style:normal}.c3{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:13pt;font-family:"Arial";font-style:normal}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c15{font-weight:700;vertical-align:baseline;font-size:23pt;font-family:"Arial";font-style:normal}.c9{font-weight:400;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c6{padding-top:14pt;padding-bottom:4pt;line-height:1.15;text-align:left}.c13{padding-top:18pt;padding-bottom:4pt;line-height:1.15;text-align:left}.c12{padding-top:24pt;padding-bottom:6pt;line-height:1.15;text-align:left}.c10{background-color:#ffffff;max-width:451.4pt;padding:72pt 72pt 72pt 72pt}.c7{color:#1155cc;text-decoration:underline}.c14{padding:0;margin:0}.c5{color:inherit;text-decoration:inherit}.c8{margin-left:36pt;padding-left:0pt}.c11{font-style:italic}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c10"><h3 class="c6" id="h.tzy0o6nooxad"><span class="c3">Sean Stavropoulos</span></h3><p class="c2"><span class="c0">An aerospace engineer passionate about software. I love bringing valuable tech ideas to life through web and mobile applications.</span></p><p class="c2"><span class="c7"><a class="c5" href="https://www.google.com/url?q=http://twitter.com/seanstavro&amp;sa=D&amp;ust=1497017540428000&amp;usg=AFQjCNGyTGBaIlaVh_qweZmfnzpjDoRFzQ">Twitter</a></span><span>&nbsp;</span><span class="c7"><a class="c5" href="https://www.google.com/url?q=http://linkedin.com/in/seanstavropoulos&amp;sa=D&amp;ust=1497017540429000&amp;usg=AFQjCNE4miydX_H9j83Bcxr0i89tZZLjBw">LinkedIn</a></span><span>&nbsp;</span><span class="c9 c7"><a class="c5" href="https://www.google.com/url?q=http://github.com/stavro&amp;sa=D&amp;ust=1497017540429000&amp;usg=AFQjCNFh1e6u8DP6wwAvtrV79gEGN3IUtg">Github</a></span></p><h1 class="c12" id="h.50225qx02lm4"><span class="c15 c7"><a class="c5" href="https://www.google.com/url?q=http://seanstavro.com/blog/elixir-slave-nodes/&amp;sa=D&amp;ust=1497017540430000&amp;usg=AFQjCNE4PyPbvw6QB_fdw0ORaHer2WloTg">Intro: Slave Nodes and Remote Code Loading</a></span></h1><p class="c2"><span>An introduction to slave nodes and remote code loading with the </span><span class="c7"><a class="c5" href="https://www.google.com/url?q=http://elixir-lang.org/&amp;sa=D&amp;ust=1497017540431000&amp;usg=AFQjCNGGpXWkdqyH4q6k6gcSDRMcyJrgIg">Elixir language</a></span><span class="c0">.</span></p><p class="c2"><span>Read the informational guide below, or jump straight to </span><span class="c7"><a class="c5" href="https://www.google.com/url?q=http://seanstavro.com/blog/elixir-slave-nodes-demo/&amp;sa=D&amp;ust=1497017540431000&amp;usg=AFQjCNEO6zCcpQ54yIBOtbWGwj5Ov56YYg">a distributed walkthrough in part 2</a></span><span class="c0">.</span></p><h3 class="c6" id="h.urk16qsmzni8"><span class="c3">Slave Nodes</span></h3><p class="c2"><span class="c0">Slave nodes are a powerful component of Erlang/OTP which enable distributed computing without the burden of orchestrating code deployments across multiple servers or developing custom network communication protocols. Whether you&rsquo;re leveraging a cluster of Raspberry Pis or scaling compute-intensive algorithms on EC2, slave nodes provide a straightforward architecture to scale your workload out to multiple machines with minimal overhead.</span></p><p class="c2"><span class="c0">This guide will step through some of the fundamental building blocks surrounding slave nodes to get you started with building distributed systems in Elixir.</span></p><p class="c2"><span>If availability in the presence of server failures, network partitions, or data center failures is important to your use case, the use of a decentralized, fault tolerant architecture is recommended, such as the one provided by </span><span class="c7"><a class="c5" href="https://www.google.com/url?q=https://github.com/basho/riak_core&amp;sa=D&amp;ust=1497017540433000&amp;usg=AFQjCNHuN7Y7FKuHKmm5j-j_eMnexOIToA">riak_core</a></span><span class="c0">.</span></p><h3 class="c6" id="h.1ip5fjcuv0r4"><span class="c3">Remote Code Loading</span></h3><p class="c2"><span class="c0">At its core, remote code loading describes the behavior of executing modules inside of an Erlang VM without the compiled module existing on the local filesystem.</span></p><p class="c2"><span class="c0">A naive approach of remote code loading can be implemented in just two lines of code within Erlang:</span></p><p class="c2"><span class="c0">{_Module, Binary, Filename} = code:get_object_code(Module).<br>rpc:call(Node, code, load_binary, [Module, Filename, Binary]).</span></p><p class="c2"><span class="c0">However, this style of remote code loading places unnecessary burden on the application code to serialize, distribute, and load binary files. By using proper remote code loading techniques you can fully leverage advanced code-management features such as on-demand code loading and hot code swaps.</span></p><h2 class="c13" id="h.v22c7kjvq6zu"><span class="c4">Understanding Erlang Code</span></h2><p class="c2"><span class="c0">To properly understand remote code loading, it is necessary to take a step back and look at the building blocks of Erlang.</span></p><h3 class="c6" id="h.rpfm4glqbspu"><span class="c3">The Module</span></h3><p class="c2"><span>The fundamental unit of code in Erlang (and thus Elixir) is a module. In fact, </span><span class="c11">all</span><span class="c0">&nbsp;written functions must be contained within a module. At its core, a module is simply collection of attributes and function declarations.</span></p><p class="c2"><span class="c0">In Erlang, a file with the extension .erl contains a single module. Elixir files, extended with .ex, may contain multiple modules, but it is both common and convenient for a single module to be in a single file.</span></p><p class="c2"><span class="c0">Elixir files may contain multiple modules solely for organizational convenience. When Elixir files are compiled, each module is separated into a distinct `.beam` file with the appropriate name. Consider a single Elixir file with two modules defined:</span></p><p class="c2"><span class="c0"># test.ex<br>defmodule ModuleA do<br>end<br>defmodule ModuleB do<br>end</span></p><p class="c2"><span class="c0">Upon compilation, two distinct beam files are created:</span></p><p class="c2"><span class="c0">elixirc test.ex --verbose<br>Compiled test.ex<br><br>&gt; ls *.beam<br>Elixir.ModuleA.beam<br>Elixir.ModuleB.beam</span></p><p class="c2"><span class="c0">Modules must be compiled prior to use by the runtime system. Compilation involves expanding macros, inserting include files, generating warnings or error messages for syntax errors, and many more steps beyond the scope of this document. Compiled modules have the extension .beam. When a particular .beam module is loaded into the Erlang runtime system, the associated functions are made available.</span></p><p class="c2"><span class="c0">Beam is short for Bogdan&rsquo;s Erlang Abstract Machine; (Also referred to as Bogumil, or Bj&ouml;rn). Beam is both a binary file format and the name of the Erlang interpreter implementation that reads it.</span></p><h3 class="c6" id="h.qw76dm8c2zac"><span class="c3">Node</span></h3><p class="c2"><span class="c0">A node is simply a running Erlang Virtual Machine (VM).</span></p><p class="c2"><span>The </span><span class="c11">only</span><span class="c0">&nbsp;widespread implementation of the Erlang VM is what we refer to as Beam. You may think of the Erlang VM as an operating system running on top of your host operating system. It handles events, process scheduling, memory, naming services, and interprocess communication. On top of all that, a node can connect to other nodes (locally, or on remote host machines) and interact with them.</span></p><p class="c2"><span class="c0">As compiled modules are loaded into the VM, their functions and attributes are made available.</span></p><p class="c2"><span class="c0">Nodes must be given a name in order to communicate with each other. The format of the node name is an atom `name@host` where name is the name given by the user and host is the full host name if long names are used, or the first part of the host name if short names are used. `node()` returns the name of the node. Elixir example:</span></p><p class="c2"><span class="c0">$ iex --name foo<br>1&gt; node()<br>:&quot;foo@MacBook-Pro.socal.rr.com&quot;<br><br>&gt; $ iex --sname foo<br>1&gt; node()<br>:&quot;foo@MacBook-Pro&quot;</span></p><h3 class="c6" id="h.gmwtwgvsmxmv"><span class="c3">Erlang Kernel</span></h3><p class="c2"><span class="c0">The Erlang Kernel application is always the first application executed inside the Erlang VM, and contains all the code necessary to run the Erlang runtime system itself. You can see the core Kernel services by viewing the registered(). process list in a fresh Erlang VM.</span></p><p class="c2"><span class="c0">In Erlang terms, an &quot;application&quot; denotes a component that can be started and stopped as a unit, and which potentially be re-used in other systems.</span></p><p class="c2"><span class="c0">$ erl<br>Erlang/OTP 17 [...]<br><br>Eshell V6.3 &nbsp;(abort with ^G)<br>1&gt; registered().<br>[standard_error_sup,erl_prim_loader,error_logger,kernel_safe_sup,<br>init,user,rex,inet_db,kernel_sup,code_server,global_name_server,<br>application_controller,file_server_2,user_drv,standard_error,global_group]</span></p><p class="c2"><span class="c0">Of particular importance to this discussion are the code_server and erl_prim_loader modules, which together locate, load, and purge compiled beam modules. Since both Erlang and Elixir code compile to the same bytecode, the process of loading modules into the runtime is identical for Elixir as it is for Erlang after the compilation phase.</span></p><h3 class="c6" id="h.obf10eivtpb7"><span class="c3">Erlang Code Server</span></h3><p class="c2"><span>The </span><span class="c7"><a class="c5" href="https://www.google.com/url?q=http://www.erlang.org/doc/man/code.html&amp;sa=D&amp;ust=1497017540444000&amp;usg=AFQjCNGHLuuMapjYWgNC8paOmzm0u53IrQ">code server</a></span><span class="c0">&rsquo;s primary task is to manage the dynamic loading and purging of modules.</span></p><p class="c2"><span>However, the code server does </span><span class="c11">not</span><span class="c0">&nbsp;concern itself with where the files are stored. The code server treats a compiled module in the local file system identically to a compiled module from a remote source. This allows flexible code loading techniques, such as remote servers, databases, or any other storage mechanism imaginable. The desired code does not need to exist on the local filesystem!</span></p><h3 class="c6" id="h.m77jdps201hb"><span class="c3">Erlang Primitive Loader</span></h3><p class="c2"><span>The </span><span class="c7"><a class="c5" href="https://www.google.com/url?q=http://www.erlang.org/doc/man/erl_prim_loader.html&amp;sa=D&amp;ust=1497017540446000&amp;usg=AFQjCNEgJEmuUhHylUWE_Xr7aC0z3s7W6g">erl_prim_loader</a></span><span>, also known as the Low Level Erlang Loader, contains details of the runtime environment regarding </span><span class="c11">where to fetch modules</span><span class="c0">. The Erlang runtime system ships with two loader methods:</span></p><ul class="c14 lst-kix_z1nuybmtkxll-0 start"><li class="c2 c8"><span class="c0">efile (default) - Load modules from the local file system</span></li><li class="c2 c8"><span class="c0">inet - Load modules using the boot_server on another Erlang node.</span></li></ul><p class="c2"><span class="c0">To instruct an Erlang node to start up in inet mode, a command-line paramter may be passed to erl on startup. Both a cookie and the location of the desired boot server must be set. An erl_boot_servermust be running and accepting incoming connections from the host IP.</span></p><p class="c2"><span class="c0">erl -loader inet -hosts 12.34.56.78 -setcookie secret-cookie</span></p><h3 class="c6" id="h.z94efuitgy3t"><span class="c3">Erlang Boot Server</span></h3><p class="c2"><span class="c0">The final Kernel module which requires an introduction is the boot server. Within this module lies the responsibility of distributing compiled modules to remote nodes. The boot server thus typically runs on a node which contains the code on the local filesystem.</span></p><p class="c2"><span class="c0">The boot server is not started automatically by the Kernel application. For scenarios in which a boot server is desired, the Kernel must be instructed to start the boot server through configuration parameters or though application code.</span></p><p class="c2"><span class="c0">For security, the boot server must be provided a list of IP addresses for hosts which are whitelisted to boot and receive code. Erlang nodes which specify a loader method of inet on startup will contact the corresponding boot server to receive compiled code.</span></p><h2 class="c13" id="h.cekp3dsl692b"><span class="c4">Coming together</span></h2><p class="c2"><span class="c0">I realize we&rsquo;ve (very) briefly introduced a handful of objects&hellip;. So how do they all play together?</span></p><p class="c2"><span class="c0">To aid in understanding, take a minute to look at the following image which attempts to illustrate the flow of a compiled module from the local filesystem of a master node to the running VM of a remote node.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span>A master node should be started with the desired code on the local filesystem along with a boot server to distribute the code to other nodes. Additional nodes may be started with the proper configuration settings to instruct the VM to locate and load desired modules </span><span class="c11">from</span><span class="c0">&nbsp;the boot server of a master node.</span></p><p class="c2"><span>Now that we&rsquo;ve identified and laid out our building blocks for remote code loading, follow the </span><span class="c7"><a class="c5" href="https://www.google.com/url?q=http://seanstavro.com/blog/elixir-slave-nodes-demo/&amp;sa=D&amp;ust=1497017540452000&amp;usg=AFQjCNHXdwyCGBjkj-eZVTLnHdxLJhh1lQ">next post</a></span><span class="c0">&nbsp;to put together a working demo.</span></p><p class="c2"><span><br></span><span class="c3">Sean Stavropoulos</span></p><p class="c2"><span class="c0">An aerospace engineer passionate about software. I love bringing valuable tech ideas to life through web and mobile applications.</span></p><p class="c2"><span class="c7"><a class="c5" href="https://www.google.com/url?q=http://twitter.com/seanstavro&amp;sa=D&amp;ust=1497017540453000&amp;usg=AFQjCNEqRpQARnYp9ARgFFj-laAjzqG6kw">Twitter</a></span><span>&nbsp;</span><span class="c7"><a class="c5" href="https://www.google.com/url?q=http://linkedin.com/in/seanstavropoulos&amp;sa=D&amp;ust=1497017540454000&amp;usg=AFQjCNG-jsMHRZknZJg2GMrFUXscZTJC-w">LinkedIn</a></span><span>&nbsp;</span><span class="c7 c9"><a class="c5" href="https://www.google.com/url?q=http://github.com/stavro&amp;sa=D&amp;ust=1497017540454000&amp;usg=AFQjCNFvh7wsCrJZnn71GLtJYYYWAPNZ4w">Github</a></span></p><h1 class="c12" id="h.3dyst9vnfmhf"><span class="c7 c15"><a class="c5" href="https://www.google.com/url?q=http://seanstavro.com/blog/elixir-slave-nodes-demo/&amp;sa=D&amp;ust=1497017540455000&amp;usg=AFQjCNFnKkLDGXv8osl_LA9R2bjb57eW6g">Demo: Remote Code Loading</a></span></h1><p class="c2"><span>If you&rsquo;ve come straight to this page, you may want to step back and reference </span><span class="c7"><a class="c5" href="https://www.google.com/url?q=http://seanstavro.com/blog/elixir-slave-nodes/&amp;sa=D&amp;ust=1497017540456000&amp;usg=AFQjCNEjkFluMFlWLUQudiZbS9YmNfRpig">the brief introduction to remote code loading</a></span><span class="c0">&nbsp;first. Now&hellip; On with the demo!</span></p><p class="c2"><span class="c0">This guide will walk through the Elixir implementation of a basic distributed Hello World slave node.</span></p><h2 class="c13" id="h.b569p01wbu5a"><span class="c4">Setup</span></h2><p class="c2"><span class="c0">For this demo, we are going to set up two separate Digital Ocean servers, put our code on one of them, and then run a distributed application between them.</span></p><h3 class="c6" id="h.nowisysot2cz"><span class="c3">Digital Ocean Setup</span></h3><p class="c2"><span>After creating an account with Digital Ocean, make sure you </span><span class="c7"><a class="c5" href="https://www.google.com/url?q=https://www.digitalocean.com/community/tutorials/how-to-use-ssh-keys-with-digitalocean-droplets&amp;sa=D&amp;ust=1497017540458000&amp;usg=AFQjCNGFTaruZxYqLS-xhSOeCwXdgcSYQA">add an SSH keypair</a></span><span class="c0">&nbsp;to your account.</span></p><p class="c2"><span class="c0">Then, create two droplets in Digital Ocean (I chose Ubuntu for this demo - but that is not a requirement), and make sure to enable private networking for both of them. Let&rsquo;s call one the &ldquo;master&rdquo; and one the &ldquo;slave&rdquo;.</span></p><p class="c2"><span class="c0">After the droplets are created, take note of their private network IP addresses - this is what you&rsquo;ll want to use to connect the nodes to each other.</span></p><p class="c2"><span class="c0">While nodes may communicate over their public IP interfaces, this is not recommended. Communication between nodes using the private networking interface is noticably faster and will not count towards your bandwidth costs.</span></p><h3 class="c6" id="h.t6cp80nrnvld"><span class="c3">Slave Server Setup</span></h3><p class="c2"><span class="c0">The only thing we need to do for our slave nodes is install Erlang. That&rsquo;s it! Let&rsquo;s ssh onto the box we want to use as a slave node and do just that:</span></p><p class="c2"><span class="c0">ssh root@104.131.164.35 -i ~/.ssh/seanstavro-digitalocean<br><br># Download Erlang Solutions package listings<br>wget http://packages.erlang-solutions.com/erlang-solutions_1.0_all.deb<br><br># Add Erlang Solutions packages to the apt-get package manager<br>sudo dpkg -i erlang-solutions_1.0_all.deb<br>apt-get update<br><br># Install Erlang<br>apt-get install erlang</span></p><h3 class="c6" id="h.6o3d6id6d47z"><span class="c3">Master Server Setup</span></h3><p class="c2"><span>Let&rsquo;s start off by connecting through ssh onto our &ldquo;master&rdquo; server and installing our dependencies. You will need to connect to the </span><span class="c11">public</span><span class="c0">&nbsp;IP address of whichever server you choose to be the master.</span></p><p class="c2"><span class="c0">ssh root@45.55.202.19 -i ~/.ssh/seanstavro-digitalocean<br><br># Download Erlang Solutions package listings<br>wget http://packages.erlang-solutions.com/erlang-solutions_1.0_all.deb<br><br># Add Erlang Solutions packages to the apt-get package manager<br>sudo dpkg -i erlang-solutions_1.0_all.deb<br>apt-get update<br><br># Install Elixir<br>apt-get install elixir</span></p><p class="c2"><span class="c0">Next, we need to allow our master server to connect to our slave nodes. This is typically done through rsh (though you can choose an alternative). To do this, we&rsquo;re going to copy our digital ocean ssh key as id_rsa onto the master box:</span></p><p class="c2"><span class="c0">scp -i ~/.ssh/seanstavro-digitalocean ~/.ssh/seanstavro-digitalocean root@45.55.202.19:~/.ssh/id_rsa</span></p><p class="c2"><span class="c0">In a production environment, you should take caution to set up appropriate security permissions, which is beyond the scope of this tutorial.</span></p><p class="c2"><span>Next, we&rsquo;re going to test the connection to the slave node&rsquo;s </span><span class="c11">private IP address</span><span class="c0">. (It is required that you add the remote server to the known_hosts file, which is most easily done by simply testing the ssh connection).</span></p><p class="c2"><span class="c0">ssh root@10.132.162.238<br><br>The authenticity of host &#39;10.132.162.238 (10.132.162.238)&#39; can&#39;t be established.<br>ECDSA key fingerprint is a5:55:45:8d:af:6b:27:4b:d7:43:2e:da:de:15:7c:ba.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added &#39;10.132.162.238&#39; (ECDSA) to the list of known hosts.</span></p><p class="c2"><span class="c0">Wonderful! Now our master node has been shown to be able to connect to our slave node via SSH. Let&rsquo;s exit the slave server shell and get back to our Master.</span></p><h3 class="c6" id="h.anhzr05h33ep"><span class="c3">HelloMaster</span></h3><p class="c2"><span>Now that we&rsquo;ve set our Ubuntu servers up to be able to communicate with one another, the next step is to implement our Elixir applicaton code. For the sake of brevity, I have added a couple basic modules on a public github repo called </span><span class="c7"><a class="c5" href="https://www.google.com/url?q=https://github.com/stavro/hello_master&amp;sa=D&amp;ust=1497017540464000&amp;usg=AFQjCNGvWFFqCVo120u8JmLuTcDjAbD-SQ">hello_master</a></span><span class="c0">&nbsp;which we will use in this demo.</span></p><p class="c2"><span class="c0">The HelloMaster repository consists of a couple core components:</span></p><ul class="c14 lst-kix_txgin7vlyji-0 start"><li class="c2 c8"><span class="c0">A supervisor responsible for starting an erl_boot_server</span></li><li class="c2 c8"><span class="c0">A very basic GenServer which responds to a :hello message and returns the running node information.</span></li><li class="c2 c8"><span class="c0">A helper module to implement the remote procedures necessary to start and stop a remote node, as we learned about in part 1.</span></li></ul><p class="c2"><span class="c0">Now, let&rsquo;s clone the repo and start up an Elixir node.</span></p><p class="c2"><span class="c0">git clone https://github.com/stavro/hello_master.git<br>cd hello_master</span></p><p class="c2"><span>We need to pay special attention to starting our Erlang VM to ensure that it is started in a distribution-friendly way. Specifically, our node needs to be assigned both a </span><span class="c11">cookie</span><span>&nbsp;and a </span><span class="c11">name</span><span class="c0">. For convention during this demonstration, I am using the form master@private-ip.</span></p><p class="c2"><span class="c0">iex --cookie cookie --name master@10.132.162.237 -S mix</span></p><p class="c2"><span class="c0">Nodes with long names cannot communicate with a node with a short name.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span>In general, if nodes will only communicate with each other on the same server or local network, feel free to use short names for convenience. However, if you require distributed server communication across a global network, use long names. For more information on setting up a cluster, please reference the </span><span class="c7"><a class="c5" href="https://www.google.com/url?q=http://learnyousomeerlang.com/distribunomicon&amp;sa=D&amp;ust=1497017540469000&amp;usg=AFQjCNHNO7-RmNq_TBGiMUBWPB7pkYOjrw">Distribunomicon</a></span><span class="c0">.</span></p><p class="c2"><span class="c0">Now that we&rsquo;re inside of our master Erlang VM, starting a slave node on any server which our existing VM can access is as simple as passing in the private IP of that server:</span></p><p class="c2"><span class="c0">{:ok, server} = HelloMaster.SlaveNode.start(&quot;10.132.162.238&quot;)</span></p><p class="c2"><span class="c0">And now finally, let&rsquo;s invoke the Hello World server running inside the slave node on a remote host:</span></p><p class="c2"><span class="c0">{:ok, remote_pid} = HelloMaster.SlaveNode.call(server, HelloMaster.Echo, :start_link, [])<br><br>HelloWorld.hello(remote_pid)<br>{:ok, &quot;Hello from slave@10.132.162.238&quot;}</span></p><p class="c2"><span>To summarize, we&rsquo;ve installed Erlang and Elixir on one server, added some of our application code, and enabled an ssh communication channel from our master node to our slave node. Then, through the power of Erlang/OTP, we started a remote Erlang node running our code </span><span class="c11">on a completely separate host</span><span class="c0">.</span></p><p class="c2"><span class="c0">I hope you enjoyed this journey into Elixir and Erlang slave nodes. Stay tuned for more posts!</span></p><p class="c1"><span class="c0"></span></p></body></html>